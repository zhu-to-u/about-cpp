# 算法

## 函数对象

重载函数调用操作符的类,其对象常称为函数对象,即他们是行为类似函数的对象,也叫仿函数,其实就是重载"()"操作符,是的类对象可以像函数那样调用

注意

函数对象(仿函数)是一个类,不是一个函数

函数对象(仿函数)重载了"()"操作符使得它可以像一个函数一样调用

分类:假定某个类有一个重载的operator(),而且重载的operator()要求获取一个参数,我们就将这个类称为"一元仿函数";相反的,如果重载的operator()要求获取两个参数,就将这个类称为"二元仿函数"

STL提供的算法往往都有两个版本,其中一个版本表现出最常用的某种运算,另一版本则允许用户通过template参数的形式来指定所要采取的策略

```cpp
//函数对象是重载了函数调用符号的类
class MyPrint
{
public:
    MyPrint()
    {
        num=0;
    }
    int num;
    
    void operator()(int num)//一个参数,一元仿函数
    {
        cout<<num<<endl;
        num++;
    }
};

```

总结:

1. 函数对象通常不定义构造函数和析构函数,所以在构造的析构时不会发生任何问题,避免了函数调用的运行问题
2. 函数对象超出普通函数的概念,因为函数对象可以有自己的状态
3. 函数对象可以内联编译,性能好.用函数指针几乎不可能
4. 模板函数对象具有通用性,这也是它的优势之一

## 谓词

谓词是指普通函数或重载的operator()返回值是bool类型的函数对象(仿函数).如果operator接受一个参数,那么叫做一元谓词.如果接受两个参数,那么叫做二元谓词,谓词可作为一个判断式

```cpp
class GreaterThenFive
{
public:
    bool operator()(int num)//一元谓词
    {
        return num>5;
    }
};
```

## 内建函数对象

STL内建了一些函数对象.分为算数类函数对象,关系运算类函数对象,逻辑运算类仿函数.这些仿函数所产生的对象,用法和一般函数完全相同,当然我们还可以产生无名的临时对象来履行函数功能.使用内建函数对象,需要引入头文件#include<functional>

## 适配器

### 函数对象适配器

```cpp
#include<iostream>
#include<functional>
#include<vector>
#include<algorithm>
using namespace std;

class MyPrint:public binary_function<int,int,void>
{
public:
    void operator()(int val,int start)const
    {
        cout<<val+start<<endl;
    }
};

void test01()
{
    
    vector<int> v;
    
    for(int i=0;i<10;i++)
    {
        v.push_back(i);
    }
    cout<<"请输入起始值:"<<endl;
    int num;
    cin>>num;
    //函数对象适配器
    for_each(v.begin(),v.end(),bind2nd(MyPrint(),num));
}

//1.利用bind2nd进行绑定
//2.继承public binary_function<参数1类型,参数2类型,返回值类型>
//3.加const

int main()
{
    test01();
    return 0;
}
```

### 取反适配器

```cpp
#include<iostream>
#include<vector>
#include<functional>
#include<algorithm>
using namespace std;

class GreaterThanFive:public unary_function<int,bool>//一元继承
{
public:
    bool operator()(int val)const
    {
        return val>5;
    }
};

void test02()
{
    //一元取反
    vector<int>v;
    for(int i=0;i<10;i++)
    {
        v.push_back(i);
    }
    cout<<"请输入起始值:"<<endl;
    int num;
    cin>>num;
   
    //vector<int>::iterator pos=find_if(v.begin(),v.end(),not1(GreaterThanFive());
    vector<int>::iterator pos=find_if(v.begin(),v.end(),not1(bind2nd(greater<int>(),num)));
    if(pos!=v.end())
    {
        cout<<"找到了小于"<<num<<"的值为:"<<*pos<<endl;
    }else{
        cout<<"未找到"<<endl;
    }                                  
}
                                      
//1.利用not1进行取反
//2.继承unary_function
//3.加const
                                      
int main()
{
    test02();
    return 0;
}
```

### 函数适配器

```cpp
#include<iostream>
#include<functional>
#include<vector>
#include<algorithm>
using namespace std;

void MyPrint(int val,int start)
{
    cout<<val+start<<endl;
}
//函数适配器
void test01()
{
    
    vector<int> v;
    
    for(int i=0;i<10;i++)
    {
        v.push_back(i);
    }
    //cout<<"请输入起始值:"<<endl;
    //int num;
    //cin>>num;
    //将函数指针适配成函数对象ptr_fun
    for_each(v.begin(),v.end(),bind2nd(ptr_fun(MyPrint),1000));
}



int main()
{
    test01();
    return 0;
}
```

#### 成员函数适配器

```cpp
#include<iostream>
#include<vector>
#include<functional>
#include<algorithm>
#include<string>
using namespace std;

class Person 
{
public:
    Person(string name,int age)
    {
        this->name=name;
        this->age=age;
    }
    
    //法二
    void showPerson()
    {
         cout<<"姓名:"<<this->name<<"年龄:"<<this->age<<endl;
    }
    
    string name;
    int age;
};

//法一
/*void MyPrint(Person&p)
{
    cout<<"姓名:"<<p.name<<"年龄:"<<p.age<<endl;
}*/

void test01()
{
    vector<Person>v;
    
    Person p1("aaa",10);
    Person p2("bbb",20);
    Person p3("ccc",30);
    Person p4("ddd",40);
    v.push_back(p1);
    v.push_back(p2);
    v.push_back(p3);
    v.push_back(p4);
    
    //for_each(v.begin(),v.end(),MyPrint);//回调函数只要把函数名放进去就可以
    for_each(v.begin(),v.end(),mem_fun_ref(&Person::showPerson));
}

int main()
{
    test01();
    return 0;
}
```
//如果存放的是对象指针,关键字mem_fun
//如果是存放的对象,关键字mem_fun_ref
